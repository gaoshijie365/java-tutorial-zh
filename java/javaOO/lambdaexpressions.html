<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
    

<html lang="en-US" xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Lambda 表达式 (Java&trade; 教程 &gt;
            学习 Java &gt; 类和对象)
</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
     <meta name="description" content="This beginner Java tutorial describes fundamentals of programming in the Java programming language" />
     <meta name="keywords" content="java programming, learn java, java sample code, java objects, java classes, java inheritance, interfaces, variables, arrays, data types, operators, control flow, number, string, package, expression, statement, block, enum, annotation, character, generics" />
        
<style type="text/css">
    body {
        margin-left:10px;
        margin-right:10px;
        line-height: 1.5;
        FONT-FAMILY: Arial, Helvetica, sans-serif; 
        font-size: 0.8em;
    }
    
    a:link{text-decoration:none; color:#09569d;}
    a:visited{text-decoration:none; color: #3a87cf;}
    a:hover{text-decoration:underline; }
        
    code{
        font-family:Monaco,Courier,"Courier New";
    }
    
    .header-container {
        background-color: #fff;
        border-bottom: 1px solid #C1CFDA;
        -webkit-box-shadow: 0 2px 2px rgba(117, 163, 231, 0.1);
        box-shadow: 0 2px 2px rgba(117, 163, 231, 0.1);
    }
    
    .bookwrapper {
        width: auto;
        margin: auto;
    }
    
    .clearfix {
    }
    
    .clearfloat {
        clear: both;
        overflow: auto;
        height: 0px;
        font-size: 1px;
        line-height: 0px;
    }
    
    #brandProdName {
        width: auto;
        height: auto;
    }
    
    #logocover {
        display: block;
        background: transparent url(../../images/oracle-java-logo.png) 0px 0px no-repeat;
        height: 50px;
        width: 229px;
        float: left;
    }
    
    #productName {
        font-size: 16px;
        position: relative;
        top: 19px;
        padding-left: 3px;
        color: #457798;
        white-space: nowrap;
        width: 340px;
    }


    .FigureCaption   { 
        font-family: sans-serif; 
        text-align: center;
    }
    
    #TopBar_bl {        
        width: 100%;
        height: 60px;
    }
    #TopBar_br {
        width: 100%;
        height: 60px;
    }
    #TopBar_tl {
        margin-left: -110px;
        margin-right: -100px;       
		align: left;
        height: 60px;
    }
    #TopBar_tr {
        width: 100%;
        height: 60px;
    }
    
    #TopBar {
        min-width:700px;
        padding:25px 100px 10px;
        margin-bottom:25px;
        clear:both;
        
        border-bottom:1px solid #d2dde5;
        border-radius: 3px;
    
        background:#efefef; /* Old browsers */
        /* IE9 SVG, needs conditional override of 'filter' to 'none' */
        background: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/Pgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgdmlld0JveD0iMCAwIDEgMSIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSI+CiAgPGxpbmVhckdyYWRpZW50IGlkPSJncmFkLXVjZ2ctZ2VuZXJhdGVkIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjAlIiB5MT0iMCUiIHgyPSIwJSIgeTI9IjEwMCUiPgogICAgPHN0b3Agb2Zmc2V0PSIwJSIgc3RvcC1jb2xvcj0iI2ZmZmZmZiIgc3RvcC1vcGFjaXR5PSIxIi8+CiAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0b3AtY29sb3I9IiNlMmVmZjkiIHN0b3Atb3BhY2l0eT0iMSIvPgogIDwvbGluZWFyR3JhZGllbnQ+CiAgPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjEiIGhlaWdodD0iMSIgZmlsbD0idXJsKCNncmFkLXVjZ2ctZ2VuZXJhdGVkKSIgLz4KPC9zdmc+);
        background: -moz-linear-gradient(top,  #ffffff 0%, #e2eff9 100%); /* FF3.6+ */
        background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#ffffff), color-stop(100%,#e2eff9)); /* Chrome,Safari4+ */
        background: -webkit-linear-gradient(top,  #ffffff 0%,#e2eff9 100%); /* Chrome10+,Safari5.1+ */
        background: -o-linear-gradient(top,  #ffffff 0%,#e2eff9 100%); /* Opera 11.10+ */
        background: -ms-linear-gradient(top,  #ffffff 0%,#e2eff9 100%); /* IE10+ */
        background: linear-gradient(to bottom,  #ffffff 0%,#e2eff9 100%); /* W3C */
        filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#ffffff', endColorstr='#e2eff9',GradientType=0 ); /* IE6-8 */
        
    }
    
    #TopBar_left {
        line-height: 14px;
        position: absolute;
        padding-top: 30px;
        padding-right: 30px;
        padding-left: 30px;
        text-align: left;
        font: 13px/20px Arial, Helvetica, sans-serif;
        font-weight: bold;
        font-size: 20px;
        color: #333;
    }
    
    #TopBar_right {
        line-height: 12px;
        float: right;
        padding-top: 10px;
        padding-right: 30px;
        text-align: left;
    }
    

    @media print {
        #BreadCrumbs, #Download {
            display: none;
        }
    }
    
     
    @media print {
        #TopBar_right {
            display: none;
        }
    }
    #TopBar_right a {
        font-size: 10px;
        margin: 3px;
        padding: 0;
    }
 
    #BreadCrumbs {
        padding: 15px 5px 0.5em 0;
        font-family: sans-serif; 
        float: right;
    }
    
    #BreadCrumbs a {
        color:#09569d;
    }
    
    #BreadCrumbs a:visited, #BreadCrumbs a:link {
        text-decoration: none;
    }
    
    #BreadCrumbs a:hover, #BreadCrumbs a:active {
        text-decoration: underline;
    }
    
    #PageTitle {
        margin: 0 5px 0.5em 0;
        color: #F90000;
    }
    
    #PageContent{
        margin: 0 5px 0 20px;
    }
    
    .LeftBar_shown {
        width: 13em;
        float: left;
    }
    
    @media print {
        .LeftBar_shown {
            display: none;
        }
    }
    
    .LeftBar_hidden {
        display: none;
    }
    
    #Footer {
        padding-top: 10px;
        padding-left: 10px;
        margin-right: 10px;       
    }
    
    .footertext {
        font-size: 10px;
        font-family: sans-serif; 
        margin-top: 1px;
    }

    .NavBit  {
        padding: 15px 5px 0.5em 0;
        font-family: sans-serif; 
    }
    
    @media print {
        .NavBit {
            display: none;
        }
    }
    
    #TagNotes {
        text-align: right;        
    }
    
    @media print {
        #TagNotes a:visited, #TagNotes a:link {
            color: #35556B;
            text-decoration: none;
        }
    }
    
    #Contents a, .NavBit a, #TagNotes a {
        color:#09569d;
    }
    
    #TagNotes a:visited, #TagNotes a:link,
    #Contents a:visited, #Contents a:link,
    .NavBit a:visited, .NavBit a:link {
        text-decoration: none;
    }
    
    #TagNotes a:hover, #TagNotes a:active,   
    #Contents a:hover, #Contents a:active,   
    .NavBit a:hover, .NavBit a:active {  
        text-decoration: underline;
    }
    
    #Contents {
        float: left;
        font-family: sans-serif; 
    }
    @media print {
        #Contents {
            display: none;
        }
    }
    @media screen {
        div.PrintHeaders {
            display: none;
        }
    }
    .linkLESSON, .nolinkLESSON {
        margin-left: 0.5em;
        text-indent: -0.5em;
    }
    .linkAHEAD, .nolinkAHEAD, .linkQUESTIONS, .nolinkQUESTIONS   {
        margin-left: 1.5em; 
        text-indent: -0.5em
    }
    .linkBHEAD, .nolinkBHEAD   {
        margin-left: 2.5em;
        text-indent: -0.5em
    }
    .linkCHEAD, .nolinkCHEAD   {
        margin-left: 3.5em;
        text-indent: -0.5em
    }
    .nolinkLESSON, .nolinkAHEAD, .nolinkBHEAD, .nolinkCHEAD,
    .nolinkQUESTIONS {
        font-weight: bold;
        color: #333;
		
		
    }
    .MainFlow_indented {
        margin-right: 10px;
        margin-left: 15em;
        margin-bottom: 2em;

    }
    .MainFlow_wide {
	
        margin-right: 10px;
        margin-left: 10px;
        margin-bottom: 2em;

    }
    @media print {
        .MainFlow_indented, .MainFlow_wide {
            padding-top: 0;
            margin-top: 10px;
            margin-right: 10px;
            margin-left: 0;
        }
    }
    h1, h2, h3, h4, h5 {
        color: #333;
        
    }

    h1 {
        font-weight: bold;
        font-size: 20px;
    }

    h2 {
        font-weight: bold;
        font-size: 17px;
    }

    h3 {
        font-weight: bold;
        font-size: 14px;
    }

    h4 {
        font-size: 15px;
    }

    h5 {
        font-size: 12px;
    }


    #ToggleLeft {
        display: none;
    }
    
    .note {
        margin: 0 30px 0px 30px;
    }
    
    .codeblock {
        margin: 0 30px 0px 30px;
		font-size:12px;
		font-family:Monaco,Courier,"Courier New";
    }
    
    .tocli {
        list-style-type:none;
    }

    .betadraft {
        color: red;
    }

</style>
<script type="text/javascript">
/* <![CDATA[ */
    function leftBar() {
        var nameq = 'tutorial_showLeftBar='
        var cookies = document.cookie.split(';');
        for (var i = 0; i < cookies.length; i++) {
            var cookieString = cookies[i];
            while (cookieString.charAt(0) == ' ') {
                cookieString = cookieString.substring(1, cookieString.length);
            }
            if (cookieString.indexOf(nameq) == 0) {
                cookieValue =  cookieString.substring(nameq.length,
                        cookieString.length);
                return cookieValue == 'yes';
            }
        }
        return true;
    }

    function showLeft(b) {
        var contents = document.getElementById("LeftBar");
        var main = document.getElementById("MainFlow");
        var toggle = document.getElementById("ToggleLeft");
        if (b) {
            contents.className = "LeftBar_shown";
            main.className = "MainFlow_indented";
            toggle.innerHTML = "隐藏目录";
            document.cookie = 'tutorial_showLeftBar=yes; path=/';
        } else {
            contents.className = "LeftBar_hidden";
            main.className = "MainFlow_wide";
            toggle.innerHTML = "显示目录";
            document.cookie = 'tutorial_showLeftBar=no; path=/';
        }
    }

    function toggleLeft() {
        showLeft(document.getElementById("LeftBar").className ==
                "LeftBar_hidden");
        document.getElementById("ToggleLeft").blur();
    }

    function load() {
        showLeft(leftBar());
        document.getElementById("ToggleLeft").style.display="inline";
    }

    function showCode(displayCodePage, codePath) {
        var codePathEls = codePath.split("/");
        var currDocPathEls = location.href.split("/");
        //alert ("codePathEls = " + codePathEls + "\n" + "currDocPathEls = " + currDocPathEls);
        currDocPathEls.pop(); // remove file name at the end
        while (codePathEls.length > 0) {
            if (codePathEls[0] == "..") {
                codePathEls.shift();
                currDocPathEls.pop();
            } else {
                break;
            }
        }
        var fullCodePath = currDocPathEls.join("/") + "/" + codePathEls.join("/");
        //alert ("fullCodePath = " + fullCodePath );
        if (codePath.indexOf(".java") != -1 || codePath.indexOf(".jnlp") != -1) {
            window.location.href = displayCodePage + "?code=" + encodeURI(fullCodePath);
        } else {
            window.location.href = fullCodePath;
        }
    }
/* ]]> */    
</script>


    </head>
<body onload="load()">
    <noscript>
        要使此页面正常运行，需要启用了 JavaScript 的浏览器。
    </noscript>
        <!-- header -->
    <div class="header-container">
        <div class="bookwrapper  clearfix">       
            <div id="brandProdName">
                <div id="logocover"></div>
                <div id="productName" >文档</div>
            </div> 
            <br class="clearfloat" />
        </div>
    </div>
    
    <div id="TopBar">
        <div id="TopBar_tr">
            <div id="TopBar_tl">
                <div id="TopBar_br"> <div id="TopBar_bl"> 
                    <div id="TopBar_left">Java&trade; 教程</div>
                        <div id="TopBar_right"> 
                            <!--
                            <a href="URL" target="_blank">External Link</a><br/>
                            -->

<script type="text/javascript">function search() { var sform = document.getElementById("searchForm"); var srchelem = document.getElementById("searchField"); var srchelemreal = document.getElementById("keywordreal"); var srchval = srchelem.value; if (srchval.length == 0) { return false; } srchelemreal.value = srchval; sform.action = "http://docs.oracle.com/apps/search/search.jsp"; sform.method = "get"; sform.target = "_blank"; sform.submit(); }</script><form id="searchForm" onsubmit="return search()"><input type="hidden" name="category" value="java"/><input type="hidden" name="product" value="e25407-01"/><input type="hidden" name="q" value="" id="keywordreal"/><label for="searchField"><input type="text" id="searchField" size="30" onclick="this.value='';" /></label><input type="submit" value="Search" /></form>
              
                            <a href="javascript:toggleLeft()" id="ToggleLeft">隐藏目录</a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>


    <div id="LeftBar" class="LeftBar_shown">
        <div id="Contents">
            <div class="linkLESSON"><a href="index.html">类和对象</a></div>
<div class="linkAHEAD"><a href="classes.html">类</a></div>
<div class="linkBHEAD"><a href="classdecl.html">声明类</a></div>
<div class="linkBHEAD"><a href="variables.html">声明成员变量</a></div>
<div class="linkBHEAD"><a href="methods.html">定义方法</a></div>
<div class="linkBHEAD"><a href="constructors.html">为您的类提供构造器</a></div>
<div class="linkBHEAD"><a href="arguments.html">传递信息到方法或构造器</a></div>
<div class="linkAHEAD"><a href="objects.html">对象</a></div>
<div class="linkBHEAD"><a href="objectcreation.html">创建对象</a></div>
<div class="linkBHEAD"><a href="usingobject.html">使用对象</a></div>
<div class="linkAHEAD"><a href="more.html">更多关于类的信息</a></div>
<div class="linkBHEAD"><a href="returnvalue.html">从方法返回值</a></div>
<div class="linkBHEAD"><a href="thiskey.html">使用 this 关键字</a></div>
<div class="linkBHEAD"><a href="accesscontrol.html">控制对类成员的访问</a></div>
<div class="linkBHEAD"><a href="classvars.html">理解类成员</a></div>
<div class="linkBHEAD"><a href="initial.html">初始化字段</a></div>
<div class="linkBHEAD"><a href="summaryclasses.html">创建和使用类和对象总结</a></div>
<div class="linkQUESTIONS"><a href="QandE/creating-questions.html">问题和练习</a></div>
<div class="linkQUESTIONS"><a href="QandE/objects-questions.html">问题和练习</a></div>
<div class="linkAHEAD"><a href="nested.html">嵌套类</a></div>
<div class="linkBHEAD"><a href="innerclasses.html">内部类示例</a></div>
<div class="linkBHEAD"><a href="localclasses.html">局部类</a></div>
<div class="linkBHEAD"><a href="anonymousclasses.html">匿名类</a></div>
<div class="nolinkBHEAD">Lambda 表达式</div>
<div class="linkCHEAD"><a href="methodreferences.html">方法引用</a></div>
<div class="linkBHEAD"><a href="whentouse.html">何时使用嵌套类、局部类、匿名类和 lambda 表达式 </a></div>
<div class="linkQUESTIONS"><a href="QandE/nested-questions.html">问题和练习</a></div>
<div class="linkAHEAD"><a href="enum.html">枚举类型</a></div>
<div class="linkQUESTIONS"><a href="QandE/enum-questions.html">问题和练习</a></div>
</div>
    </div>
    <div id="MainFlow" class="MainFlow_indented">
    <div class="PrintHeaders">
        <b>路径：</b> 学习 Java
        <br /><b>课程：</b> 类和对象
        <br /><b>小节：</b> 嵌套类
    </div>
            <div id="BreadCrumbs">
                <a href="../../index.html" target="_top">主页</a>
                &gt;
                <a href="../index.html" target="_top">学习 Java</a>
                &gt;
                <a href="index.html" target="_top">类和对象</a>
            </div>
            <div class="NavBit">
                <a target="_top" href="anonymousclasses.html">&laquo;&nbsp;上一页</a>&nbsp;&bull;&nbsp;<a target="_top" href="../TOC.html">目录</a>&nbsp;&bull;&nbsp;<a target="_top" href="methodreferences.html">下一页&nbsp;&raquo;</a>
            </div>
            <div class="Banner"><p style="background-color: rgb(247, 248, 249); border-width: 1px; padding: 10px; font-style: italic; border-style: solid; border-color: rgb(64, 74, 91);">本教程基于 JDK 8 编写。教程中的示例和练习没有用到后续发布版本中的特性，并且可能使用过时的技术。<br/>查看 <a href="https://docs.oracle.com/pls/topic/lookup?ctx=en/java/javase&id=java_language_changes">Java 语言变更</a> 了解 Java SE 9 及后续发布版本的语言更新概要。<br/>查看 <a href="https://www.oracle.com/technetwork/java/javase/jdk-relnotes-index-2162236.html">JDK 发布说明</a> 了解所有 JDK 发布版本关于新特性、增强、移除或废弃选项的信息。</p></div>
            <div id="PageTitle"><h1>Lambda 表达式</h1></div>
            <div id="PageContent">

<p>匿名类存在的一个问题是，如果匿名类的实现非常简单，比如仅包含一个方法的接口，匿名类的语法看起来就会既笨重又不清晰。
    这种情况下，您通常会将函数作为参数传递给另一个方法，比如，当点击按钮时应该采取的操作。Lambda 表达式允许您这么做，它将函数视为方法参数，或者代码作为数据。</p>

<p>前一节，<a class="TutorialLink" target="_top" href="anonymousclasses.html">匿名类</a>，向您展示了如何实现一个基类而不定义名称。
    尽管这比匿名类更加简洁，但对于仅有一个方法的类，匿名类看起来还是有一点臃肿和笨重。Lambda 让您可以更紧凑地表达单一方法类的实例。</p>

<p>本节包含下面的主题：</p>

<ul>
  <li><a href="#use-case">Lambda 表达式的理想使用案例</a>
    <ul>
      <li><a href="#approach1">方法 1: 创建方法搜索与一个特征匹配的成员</a></li>
      <li><a href="#approach2">方法 2: 创建更加通用的搜索方法</a></li>
      <li><a href="#approach3">方法 3: 在局部类中指定搜索条件代码</a></li>
      <li><a href="#approach4">方法 4: 在匿名类中指定搜索条件代码</a></li>
      <li><a href="#approach5">方法 5: 使用 Lambda 表达式指定搜索条件代码</a></li>
      <li><a href="#approach6">方法 6: 在 Lambda 表达式中使用标准的函数式接口</a></li>
      <li><a href="#approach7">方法 7: 在应用中使用 Lambda 表达式</a></li>
      <li><a href="#approach8">方法 8: 使用泛型</a></li>
      <li><a href="#approach9">方法 9: 使用接收 Lambda 表达式作为参数的聚合操作</a></li>
    </ul>
  </li>
  <li><a href="#lambda-expressions-in-gui-applications">GUI 应用中的 Lambda 表达式</a></li>
  <li><a href="#syntax">Lambda 表达式的语法</a></li>
  <li><a href="#accessing-local-variables">访问外部作用域的局部变量</a></li>
  <li><a href="#target-typing">目标类型</a>
    <ul>
      <li><a href="#target-types-and-method-arguments">目标类型和方法参数</a></li>
    </ul>
  </li>
  <li><a href="#serialization">序列化</a></li>
</ul>

<h2><a name="use-case">Lambda 表达式的理想使用场景</a></h2>

<p>假设您创建了一个社交网络应用。您想要创建一项特性，允许管理员执行任何种类的操作，比如给社交网络应用中满足特定条件的成员发送一条消息。下表详细描述了这个用例：</p>

<table border="1" summary="Use case for social networking application">
  <tr>
    <th id="h1">字段</th>
    <th id="h2">描述</th>
  </tr>

  <tr>
    <td headers="h1">名称</td>
    <td headers="h2">在选中的成员上执行操作</td>
  </tr>

  <tr>
    <td headers="h1">主要参与者</td>
    <td headers="h2">管理员</td>
  </tr>

  <tr>
     <td headers="h1">前置条件</td>
     <td headers="h2">管理员登录进系统</td>
  </tr>

  <tr>
    <td headers="h1">后置条件</td>
    <td headers="h2">仅在满足特定条件的成员上执行特定操作</td>
  </tr>

  <tr>
    <td headers="h1">主要成功场景</td>
    <td headers="h2">
      <ol>
        <li>管理员指定要执行特定操作的成员要满足的条件。</li>
        <li>管理员为选中的成员指定一个操作。</li>
        <li>管理员选择 <strong>Submit</strong> 按钮。</li>
        <li>系统查找所有匹配条件的成员。</li>
        <li>系统对所有匹配的成员执行这个指定的操作。</li>
      </ol>
    </td>
  </tr>

  <tr>
    <td headers="h1">扩展</td>
    <td headers="h2">
      <p>1a. 管理员有一个选项，可以在执行特性操作前，或者选择 <strong>Submit</strong> 按钮前，查看匹配特定条件的成员。</p>
    </td>
  </tr>

  <tr>
    <td headers="h1">发生频率</td>
    <td headers="h2">一天中多次。</td>
  </tr>
</table>

<p>假设这个社交网络应用的成员用下面的 <a class="SourceLink" target="_blank" href="examples/Person.java" onclick="showCode('../../displayCode.html', 'examples/Person.java'); return false;"><code>Person</code></a> 类表示：</p>

<pre class="codeblock">public class Person {

    public enum Sex {
        MALE, FEMALE
    }

    String name;
    LocalDate birthday;
    Sex gender;
    String emailAddress;

    public int getAge() {
        // ...
    }

    public void printPerson() {
        // ...
    }
}</pre>

<p>假设社交网络应用的成员存储在 <code>List&lt;Person&gt;</code> 中。</p>

<p>本节的开始使用一个不成熟的方法。然后使用局部类和匿名类对它进行改进，最后使用最高效和简洁的 lambda 表达式。在 <a class="SourceLink" target="_blank" href="examples/RosterTest.java" onclick="showCode('../../displayCode.html', 'examples/RosterTest.java'); return false;"><code>RosterTest</code></a> 例子中可以找到本节中代码片段。</p>

<h3><a name="approach1">方法 1: 创建方法搜索与一个特征匹配的成员</a></h3>

<p>最简单的方法是创建多个方法，每个方法搜索匹配一个特性的成员，比如性别或年龄。下面的方法打印大于指定年龄的成员：</p>


<pre class="codeblock">public static void printPersonsOlderThan(List&lt;Person&gt; roster, int age) {
    for (Person p : roster) {
        if (p.getAge() &gt;= age) {
            p.printPerson();
        }
    }
}</pre>

<p><b>注意</b>:
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html"><code>List</code></a> 是一个有序
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html"><code>Collection</code></a>。
    <em>集合</em> 是一个对象，将多个元素放入单一的单元中。集合用于存储、获取、操作和表达聚合数据。关于集合的更多信息，参见 <a class="TutorialLink" target="_top"
                                                                                                                      href="../../collections/index.html">Collections</a>。</p>

<p>这个方法会导致程序变得 <em>脆弱</em>，可能是因为引入了更新而导致程序无法工作 (比如引入新的数据类型)。
    假设更改了 <code>Person</code> 类的结构，使其包含不同的成员变量，可能是使用一个不同的数据类型或算法记录和计算年龄。
    您必须根据这个变更重写大量的 API。此外，这中方法有一些限制，比如您想打印小于特定年龄的用户，那该怎么办呢？</p>

<!-- ********************************************************************** -->
<h3><a name="approach2">方法 2: 创建更加通用的搜索方法</a></h3>

<p>下面的方法比 <code>printPersonsOlderThan</code> 更加通用，它打印特定年龄范围的成员：</p>

<pre class="codeblock">public static void printPersonsWithinAgeRange(
    List&lt;Person&gt; roster, int low, int high) {
    for (Person p : roster) {
        if (low &lt;= p.getAge() &amp;&amp; p.getAge() &lt; high) {
            p.printPerson();
        }
    }
}</pre>


<p>如果想要打印特定性别的成员，或者特定性别和年龄范围的组合？如果您决定修改 <code>Person</code> 类并添加其它的属性，比如关系状态或地理位置？
    尽管这个方法比 <code>printPersonsOlderThan</code> 更通用，为每个可能的搜索查询创建单独的方法依然会导致代码脆弱。
    您可以将指定特定条件的代码拆分到不同的类中。</p>

<!-- ********************************************************************** -->
<h3><a name="approach3">方法 3: 在局部类中指定搜索条件代码</a></h3>

<p>下面的方法打印匹配特定条件的成员：</p>

<pre class="codeblock">public static void printPersons(
    List&lt;Person&gt; roster, CheckPerson tester) {
    for (Person p : roster) {
        if (tester.test(p)) {
            p.printPerson();
        }
    }
}</pre>

<p>这个方法检查 <code>roster</code> 中包含的所有 <code>Person</code> 是否满足 <code>tester</code> 的搜索条件，通过 <code>tester.test</code>
    方法测试。如果 <code>tester.test</code> 方法返回 <code>true</code>，就会调用 <code>Person</code> 实例的 <code>printPerson</code> 方法。</p>

<p>为了指定搜索条件，您实现了 <code>CheckPerson</code> 接口：</p>

<pre class="codeblock">interface CheckPerson {
    boolean test(Person p);
}</pre>

<p>下面的类实现了 <code>CheckPerson</code> 接口，并且指定了 <code>test</code> 方法的实现。这个方法过滤出在美国符合服兵役标准的成员：如果
    <code>Person</code> 参数是男性并且年龄在 18 到 25 之间，返回 <code>true</code>：</p>

<pre class="codeblock">class CheckPersonEligibleForSelectiveService implements CheckPerson {
    public boolean test(Person p) {
        return p.gender == Person.Sex.MALE &amp;&amp;
            p.getAge() &gt;= 18 &amp;&amp;
            p.getAge() &lt;= 25;
    }
}</pre>

<p>为了使用这个类，您创建它的一个新实例，并调用 <code>printPersons</code> 方法：</p>

<pre class="codeblock">printPersons(
    roster, new CheckPersonEligibleForSelectiveService());</pre>

<p>尽管这个方法没那么脆弱 &#151; 改变 <code>Person</code> 结构时不必重写方法 &#151; 但依然有额外代码：一个新接口，和计划在应用中执行的每一个搜索的局部类。
    因为 <code>CheckPersonEligibleForSelectiveService</code> 实现一个接口，您可以使用匿名类代替局部类，而不必为每个搜索声明一个新的类。</p>

<!-- ********************************************************************** -->
<h3><a name="approach4">方法 4: 在匿名类中指定搜索条件代码</a></h3>

<p>下面对方法 <code>printPersons</code> 的调用其中一个参数是匿名类，过滤符合美国服兵役条件的成员：男性，年龄在 18 到 25 岁之间：</p>

<pre class="codeblock">printPersons(
    roster,
    new CheckPerson() {
        public boolean test(Person p) {
            return p.getGender() == Person.Sex.MALE
                &amp;&amp; p.getAge() &gt;= 18
                &amp;&amp; p.getAge() &lt;= 25;
        }
    }
);</pre>

<p>这中方法减少了所需代码的数量，因为不需要为每种搜索创建新的类。然而，考虑到 <code>CheckPerson</code> 接口只包含一个方法，匿名类的语法是笨重的。
    在这种情况下，您可以使用 lambda 表达式代替匿名类，这在下一节描述。</p>

<!-- ********************************************************************** -->
<h3><a name="approach5">方法 5: 使用 Lambda 表达式指定搜索条件代码</a></h3>

<p><code>CheckPerson</code> 接口是一个 <i>函数式接口</i>。函数式接口是进包含一个 <a class="TutorialLink" target="_top" href="../../java/IandI/abstract.html">abstract method</a> 的接口。
    (函数式接口可以包含一个或多个 <a class="TutorialLink" target="_top" href="../../java/IandI/defaultmethods.html">默认方法</a> 或 <a
            class="TutorialLink" target="_top" href="../../java/IandI/defaultmethods.html#static">静态方法</a> 。)
    因为函数式接口仅有一个抽象方法，当您实现它的时候可以省略它的名字。使用 <i>lambda 表达式</i> 代替匿名类表达式，下面方法调用中高亮部分就是：</p>

<pre class="codeblock">printPersons(
    roster,
    <strong>(Person p) -&gt; p.getGender() == Person.Sex.MALE
        &amp;&amp; p.getAge() &gt;= 18
        &amp;&amp; p.getAge() &lt;= 25</strong>
);</pre>

<p>查看 <a href="#syntax">Lambda 表达式的语法</a> 获取关于如何定义 lambda 表达式的信息。</p>

<p>您可以使用标准的函数式接口代替 <code>CheckPerson</code> 接口，这可以进一步减少所需的代码量。</p>

<!-- ********************************************************************** -->
<h3><a name="approach6">方法 6: 在 Lambda 表达式中使用标准的函数式接口</a></h3>

<p>重新考虑 <code>CheckPerson</code> 接口：</p>

<pre class="codeblock">interface CheckPerson {
    boolean test(Person p);
}</pre>

<p>这是个非常简单的接口。它是个函数式接口，因为它只包含一个抽象方法。这个方法接收一个参数并且返回一个 <code>boolean</code> 值。
    这个方法是如此简单，可能不值得在您的应用中定义一个。所以，JDK 定义了一些标准的函数式接口，您可以在 <code>java.util.function</code> 包中找到。</p>

<p>比如，您可以使用 <code>Predicate&lt;T&gt;</code> 接口代替 <code>CheckPerson</code> 接口。这个接口包含方法 <code>boolean test(T t)</code>：</p>


<pre class="codeblock">interface Predicate&lt;T&gt; {
    boolean test(T t);
}</pre>

<p><code>Predicate&lt;T&gt;</code> 是一个泛型接口。(有关泛型的更多信息，查看
<a class="TutorialLink" target="_top" href="../../java/generics/index.html">泛型 (已更新)</a> 课程。) 泛型类型 (比如泛型接口) 在尖括号
    (<code>&lt;&gt;</code>) 中指定一个或多个类型参数。这个接口仅包含一个类型参数 <code>T</code>。当您使用实际类型参数声明或实例化一个泛型类型时，
    您得到了一个参数化的类型。比如，参数化类型 <code>Predicate&lt;Person&gt;</code> 如下：</p>

<pre class="codeblock">interface Predicate&lt;<code>Person</code>&gt; {
    boolean test(<code>Person</code> t);
}</pre>

<p>这个参数化类型包含一个方法，其返回类型和参数和 <code>CheckPerson.boolean test(Person p)</code> 一样。所以您可以使用 <code>Predicate&lt;T&gt;</code>
    替代 <code>CheckPerson</code>，如下所示：</p>

<pre class="codeblock">public static void printPersonsWithPredicate(
    List&lt;Person&gt; roster, Predicate&lt;Person&gt; tester) {
    for (Person p : roster) {
        if (tester.test(p)) {
            p.printPerson();
        }
    }
}</pre>

<p>结果是，下面的方法调用效果与 <a href="#approach3">方法 3: 在局部类中指定搜索条件代码</a> 中的 <code>printPersons</code> 一样：</p>

<pre class="codeblock">printPersonsWithPredicate(
    roster,
    p -&gt; p.getGender() == Person.Sex.MALE
        &amp;&amp; p.getAge() &gt;= 18
        &amp;&amp; p.getAge() &lt;= 25
);</pre>

<p>这并不是在此方法中使用 lambda 表达式的唯一地方。下面的方法展示了使用 lambda 表达式的其它方式。</p>

<!-- ********************************************************************** -->
<h3><a name="approach7">方法 7: 在应用中使用 Lambda 表达式</a></h3>

<p>重新考虑 <code>printPersonsWithPredicate</code> 方法，看看是否还有其它地方可以使用 lambda 表达式：</p>

<pre class="codeblock">public static void printPersonsWithPredicate(
    List&lt;Person&gt; roster, Predicate&lt;Person&gt; tester) {
    for (Person p : roster) {
        if (tester.test(p)) {
            p.printPerson();
        }
    }
}</pre>

<p>这个方法检查包含在 <code>List</code> 参数 <code>roster</code> 中的每一个 <code>Person</code> 实例是否满足 <code>Predicate</code> 参数
    <code>tester</code> 中指定的条件。如果 <code>Person</code> 实例满足 <code>tester</code> 指定的条件，就会调用 <code>Person</code> 实例的
    <code>printPerson</code> 方法。</p>

<p>您可以在满足 <code>tester</code> 指定条件的 <code>Person</code> 实例上指定一个不同的操作，来代替调用 <code>printPerson</code> 方法。
    您可以使用 lambda 表达式指定这个操作。假设您想要一个类似 <code>printPerson</code> 的 lambda 表达式，接收一个参数 (一个 <code>Person</code> 类型的对象) 并返回
    void。记住，要使用 lambda 表达式，您需要实现一个函数式接口。在这个例子中，您需要一个函数式接口，包含一个抽象方法，接收一个 <code>Person</code> 类型参数并返回 void。
    <code>Consumer&lt;T&gt;</code> 接口包含方法 <code>void accept(T t)</code>，它满足这些特性。下面的方法使用调用 <code>accept</code> 方法的
    <code>Consumer&lt;Person&gt;</code> 实例代替 <code>p.printPerson()</code> 调用：</p>

<pre class="codeblock">public static void processPersons(
    List&lt;Person&gt; roster,
    Predicate&lt;Person&gt; tester,
    <strong>Consumer&lt;Person&gt; block</strong>) {
        for (Person p : roster) {
            if (tester.test(p)) {
                <strong>block.accept(p);</strong>
            }
        }
}</pre>

<p>结果是，下面的方法调用结果与 <a href="#approach3">方法 3: 在局部类中指定搜索条件代码</a> 中调用 <code>printPerson</code> 获取符合服兵役成员的结果相同。
     用来打印成员的 lambda 表达式高亮显示：</p>

<pre class="codeblock">processPersons(
     roster,
     p -&gt; p.getGender() == Person.Sex.MALE
         &amp;&amp; p.getAge() &gt;= 18
         &amp;&amp; p.getAge() &lt;= 25,
     <strong>p -&gt; p.printPerson()</strong>
);</pre>

<p>如果您想对成员做更多的分析而不仅仅是打印它们。假设您想要验证成员的资料或获取他们的联系人信息？这种情况下，您需要一个函数式接口，包含一个返回值的抽象方法。
<code>Function&lt;T,R&gt;</code> 接口包含方法 <code>R apply(T t)</code>。下面的方法获取 <code>mapper</code> 参数指定的数据，然后对它执行由
    <code>block</code> 参数指定的操作：</p>

<pre class="codeblock">public static void processPersonsWithFunction(
    List&lt;Person&gt; roster,
    Predicate&lt;Person&gt; tester,
    Function&lt;Person, String&gt; mapper,
    Consumer&lt;String&gt; block) {
    for (Person p : roster) {
        if (tester.test(p)) {
            String data = mapper.apply(p);
            block.accept(data);
        }
    }
}</pre>

<p>下面的方法获取 <code>roster</code> 中符合服兵役条件的成员的邮件地址并打印：</p>

<pre class="codeblock">processPersonsWithFunction(
    roster,
    p -&gt; p.getGender() == Person.Sex.MALE
        &amp;&amp; p.getAge() &gt;= 18
        &amp;&amp; p.getAge() &lt;= 25,
    p -&gt; p.getEmailAddress(),
    email -&gt; System.out.println(email)
);</pre>

<!-- ********************************************************************** -->
<h3><a name="approach8">方法 8: 使用泛型</a></h3>

<p>重新考虑 <code>processPersonsWithFunction</code> 方法。下面是它的泛型版本，接收包含任意数据类型元素的集合作为参数：</p>

<pre class="codeblock">public static &lt;X, Y&gt; void processElements(
    Iterable&lt;X&gt; source,
    Predicate&lt;X&gt; tester,
    Function &lt;X, Y&gt; mapper,
    Consumer&lt;Y&gt; block) {
    for (X p : source) {
        if (tester.test(p)) {
            Y data = mapper.apply(p);
            block.accept(data);
        }
    }
}</pre>

<p>为了打印负荷服兵役条件的成员的电子邮件地址，调用如下的 <code>processElements</code> 方法：</p>

<pre class="codeblock">processElements(
    roster,
    p -&gt; p.getGender() == Person.Sex.MALE
        &amp;&amp; p.getAge() &gt;= 18
        &amp;&amp; p.getAge() &lt;= 25,
    p -&gt; p.getEmailAddress(),
    email -&gt; System.out.println(email)
);</pre>

<p>这个方法调用执行下面的操作：</p>

<ol>
  <li>从 <code>source</code> 集合中获取对象源。在本例中，从集合 <code>roster</code> 集合中获取 <code>Person</code> 对象源。
      注意，<code>roster</code> 是 <code>List</code> 类型的集合，也是 <code>Iterable</code> 类型的对象。</li>
  
  <li>过滤满足 <code>Predicate</code> 对象 <code>tester</code> 的对象。在本例中，<code>Predicate</code> 对象是一个 lambda 表示，指定哪个成员将符合服兵役条件。</li>
  
  <li>由 <code>Function</code> 对象 <code>mapper</code> 将过滤后的对象映射为一个值。在本例中，<code>Function</code> 对象是一个 lambda
      表达式，返回成员的电子邮件地址。</li>
  
  <li>在每个映射后的对象上执行由 <code>Consumer</code> 对象 <code>block</code> 指定的操作。在本例中，<code>Consumer</code> 对象是一个 lambda 表达式，打印由
      <code>Function</code> 对象返回的电子邮件地址字符串。</li>
  
</ol>

<p>您可以使用聚合操作替换这些动作。</p>

<!-- ********************************************************************** -->
<h3><a name="approach9">方法 9: 使用接收 Lambda 表达式作为参数的聚合操作</a></h3>

<p>下面的例子使用聚合操作打印 <code>roster</code> 集合中满足服兵役条件的成员的电子邮件地址：</p>

<pre class="codeblock">roster
    .stream()
    .filter(
        p -&gt; p.getGender() == Person.Sex.MALE
            &amp;&amp; p.getAge() &gt;= 18
            &amp;&amp; p.getAge() &lt;= 25)
    .map(p -&gt; p.getEmailAddress())
    .forEach(email -&gt; System.out.println(email));</pre>

<p>下面的表格列出了 <code>processElements</code> 方法执行的每个操作及其对应的聚合操作：</p>

<table border="1" summary="Mapping of each of the actions the method processElements performs with the corresponding aggregate operation">
<tr>
  <th id="h101"><code>processElements</code> Action</th>
  <th id="h102">Aggregate Operation</th>
</tr>

<tr>
  <td headers="h101">获取对象源</td>
  
  <td headers="h102"><code>Stream&lt;E&gt; <strong>stream</strong>()</code></td>
</tr>

<tr>
  <td headers="h101">过滤匹配 <code>Predicate</code> 的对象</td>
  <td headers="h102"><code>Stream&lt;T&gt; <strong>filter</strong>(Predicate&lt;? super T&gt; predicate)</code></td>
</tr>

<tr>

  <td headers="h101">将对象映射为 <code>Function</code> 对象指定的另一个值</td>
  
  <td headers="h102"><code>&lt;R&gt; Stream&lt;R&gt; <strong>map</strong>(Function&lt;? super T,? extends R&gt; mapper)</code></td>
  
</tr>

<tr>
  <td headers="h101">执行由 <code>Consumer</code> 对象指定的操作</td>
  <td headers="h102"><code>void <strong>forEach</strong>(Consumer&lt;? super T&gt; action)</code></td>
</tr>

</table>

<p>操作符 <code>filter</code>、<code>map</code> 和 <code>forEach</code> 是 <em>聚合操作</em>。聚合操作处理流中的元素，而不是集合中的 (这也是在本例中第一个方法调用是
    <code>stream</code> 的原因)。<em>流</em> 是元素的序列。与集合不同，流不是用来存储元素的数据结构。流通过管道从源 (比如集合) 取值。
    <em>管道</em> 是留操作的序列，在本例中是 <code>filter</code>-<code>map</code>-<code>forEach</code>。此外，聚合操作通常接收 lambda
    表达式作为参数，以让您自定义其行为。</p>

<p>关于聚合操作更彻底的讨论，参见
<a class="TutorialLink" target="_top" href="../../collections/streams/index.html">聚合操作</a> 课程。</p>


<h2><a name="lambda-expressions-in-gui-applications">GUI 应用中的 Lambda 表达式</a></h2>

<p>为了处理图形用户界面 (GUI) 应用中的事件，比如键盘操作、鼠标操作和滚动操作，通常会创建事件处理器，其通常会实现一个特定的接口。事件处理器接口常常是一个函数式接口，它们倾向于仅有一个方法。</p>

<p>在 JavaFX 例子 <a href="https://docs.oracle.com/javase/8/javafx/get-started-tutorial/hello_world.htm">
<code>HelloWorld.java</code></a> (在前一节
<a class="TutorialLink" target="_top" href="anonymousclasses.html">匿名类</a> 中讨论)，您可以使用 lambda 表达式代替高亮的匿名内部类：</p>

<pre class="codeblock">        btn.setOnAction(<b>new EventHandler&lt;ActionEvent&gt;() {</b>

            <b>@Override</b>
            <b>public void handle(ActionEvent event) {</b>
                <b>System.out.println("Hello World!");</b>
            <b>}</b>
        <b>}</b>);</pre>

<p><code>btn.setOnAction</code> 方法调用指定了当选择由 <code>btn</code> 对象代表的按钮选中时会发生什么。这个方法要求传入一个
    <code>EventHandler&lt;ActionEvent&gt;</code> 类型的对象。<code>EventHandler&lt;ActionEvent&gt;</code> 接口仅包含一个方法
    <code>void handle(T event)</code>。这是个函数式接口，所以您可以使用下面高亮的 lambda 表达式替换它：</p>

<pre class="codeblock">        btn.setOnAction(
          <b>event -&gt; System.out.println("Hello World!")</b>
        );</pre>

<h2><a name="syntax">Lambda 表达式的语法</a></h2>

<p>一个 lambda 表达式包含以下部分：</p>

<ul>
  <li><p>包含在小括号中的逗号分隔的参数列表。<code>CheckPerson.test</code> 方法包含一个参数 <code>p</code>，代表 <code>Person</code> 类的一个实例。</p>
  <p><b>注意</b>：在 lambda 表达式中可以省略参数的数据类型。此外，如果只有一个参数的话可以省略小括号。比如，下面的 lambda 表达式也是合法的：</p>

<pre class="codeblock">p -&gt; p.getGender() == Person.Sex.MALE 
    &amp;&amp; p.getAge() &gt;= 18
    &amp;&amp; p.getAge() &lt;= 25</pre></li>

  <li><p>箭头符号 <code>-&gt;</code></p></li>
  <li><p>lambda 表达式体，包含一个表达式或一个语句块。这个例子使用下面的表达式：</p>

<pre class="codeblock">p.getGender() == Person.Sex.MALE 
    &amp;&amp; p.getAge() &gt;= 18
    &amp;&amp; p.getAge() &lt;= 25</pre>

<p>如果是单个表达式，Java 运行时会计算表达式并返回其值。当然，您也可以使用 return 语句：</p>

<pre class="codeblock">p -&gt; {
    return p.getGender() == Person.Sex.MALE
        &amp;&amp; p.getAge() &gt;= 18
        &amp;&amp; p.getAge() &lt;= 25;
}</pre>

  <p>return 语句不是表达式，在 lambda 表达式中必须将语句放在大括号 (<code>{}</code>) 中。您不必将返回 void 的方法调用放在大括号中。比如，下面是一个合法的 lambda 表达式：</p>

<pre class="codeblock">email -&gt; System.out.println(email)</pre>
</li>

</ul>

<p>lambda 表达式看起来很像方法声明，您可以认为 lambda 表达式是匿名方法&#151;没有名字的方法。</p>

<p>下面的例子，
<a class="SourceLink" target="_blank" href="examples/Calculator.java"
   onclick="showCode('../../displayCode.html', 'examples/Calculator.java'); return false;"><code>Calculator</code></a>，是接收多个参数的 lambda 表达式：</p>

<pre class="codeblock">

public class Calculator {
  
    interface IntegerMath {
        int operation(int a, int b);   
    }
  
    public int operateBinary(int a, int b, IntegerMath op) {
        return op.operation(a, b);
    }
 
    public static void main(String... args) {
    
        Calculator myApp = new Calculator();
        IntegerMath addition = (a, b) -&gt; a + b;
        IntegerMath subtraction = (a, b) -&gt; a - b;
        System.out.println(&quot;40 + 2 = &quot; +
            myApp.operateBinary(40, 2, addition));
        System.out.println(&quot;20 - 10 = &quot; +
            myApp.operateBinary(20, 10, subtraction));    
    }
}

</pre>

<p><code>operateBinary</code> 方法在两个整数操作数上执行数学操作。操作本身是通过 <code>IntegerMath</code> 实例指定的。这个例子使用 lambda 表达式定义了两个操作
    <code>addition</code> 和 <code>subtraction</code>。例子输出如下：</p>

<pre class="codeblock">40 + 2 = 42
20 - 10 = 10</pre>


<h2><a name="accessing-local-variables">访问外部作用域的局部变量</a></h2>

<p>就像局部类和匿名类，lambda 表达式也可以 <a class="TutorialLink" target="_top"
                                             href="localclasses.html#accessing-members-of-an-enclosing-class">捕获变量</a>，
    它们和外部作用域具有相同的局部变量访问权限。然而，与局部变量和匿名类不同，lambda 表达式不存在遮蔽问题 (参加 <a class="TutorialLink" target="_top"
                                                                                                                href="../../java/javaOO/nested.html#shadowing">遮蔽</a>)。
    lambda 表达式是句法作用域。这意味着它们没有从超类型继承任何名称，或者引入新一级的作用域。lambda 表达式中的声明就像它们在外部环境中那样进行解释。下面的例子，
<a class="SourceLink" target="_blank" href="examples/LambdaScopeTest.java"
   onclick="showCode('../../displayCode.html', 'examples/LambdaScopeTest.java'); return false;"><code>LambdaScopeTest
</code></a>，对此进行了说明：</p>

<pre class="codeblock">
 
import java.util.function.Consumer;
 
public class LambdaScopeTest {
 
    public int x = 0;
 
    class FirstLevel {
 
        public int x = 1;
        
        void methodInFirstLevel(int x) {

            int z = 2;
             
            Consumer&lt;Integer&gt; myConsumer = (y) -&gt; 
            {
                // The following statement causes the compiler to generate
                // the error &quot;Local variable z defined in an enclosing scope
                // must be final or effectively final&quot; 
                //
                // z = 99;
                
                System.out.println(&quot;x = &quot; + x); 
                System.out.println(&quot;y = &quot; + y);
                System.out.println(&quot;z = &quot; + z);
                System.out.println(&quot;this.x = &quot; + this.x);
                System.out.println(&quot;LambdaScopeTest.this.x = &quot; +
                    LambdaScopeTest.this.x);
            };
 
            myConsumer.accept(x);
 
        }
    }
 
    public static void main(String... args) {
        LambdaScopeTest st = new LambdaScopeTest();
        LambdaScopeTest.FirstLevel fl = st.new FirstLevel();
        fl.methodInFirstLevel(23);
    }
}</pre>

<p>这个例子产生下面的输出：</p>

<pre class="codeblock">x = 23
y = 23
z = 2
this.x = 1
LambdaScopeTest.this.x = 0
</pre>

<p>如果您使用参数 <code>x</code> 代替 lambda 表达式 <code>myConsumer</code> 中声明的 <code>y</code>，编译器将产生一个错误：</p>

<pre class="codeblock">Consumer&lt;Integer&gt; myConsumer = (x) -> {
    // ...
}</pre>

<p>编译器产生错误 "Lambda expression's parameter x cannot redeclare another local variable defined in an enclosing scope"
    因为 lambda 表达式没有引入新一级的作用域。因此，您可以直接访问外部作用域的字段、方法和局部变量。比如，lambda 表达式直接访问 <code>methodInFirstLevel</code> 方法的参数
    <code>x</code>。为访问外部类中的变量，使用 <code>this</code> 关键字。在本例中，<code>this.x</code> 指的是成员变量 <code>FirstLevel.x</code>。</p>

<p>和局部类、匿名类一样，lambda 只能访问外部作用域中的 final 或事实上 final 的局部变量和参数。在本例中，变量 <code>z</code> 是事实上 final 的，它的值在初始化之后永远不会改变。
    然而，假设您在 lambda 表达式 <code>myConsumer</code> 中添加了下面的赋值语句：</p>

<pre class="codeblock">Consumer&lt;Integer&gt; myConsumer = (y) -> {
    <strong>z = 99;</strong>
    // ...
}</pre>

<p>因为这条赋值语句，变量 <code>z</code> 不再是事实上 final 的。结果是，Java 编译器产生一条类似于 "Local variable z defined in an enclosing scope must be final or effectively final" 的错误信息。</p>

<h2><a name="target-typing">目标类型</a></h2>

<p>如何确定 lambda 表达式的类型呢？重新看一下选择男性并且年龄在 18 到 25 岁之间的成员的 lambda 表达式：</p>

<pre class="codeblock">p -&gt; p.getGender() == Person.Sex.MALE
    &amp;&amp; p.getAge() &gt;= 18
    &amp;&amp; p.getAge() &lt;= 25</pre>

<p>这个 lambda 表达式在下面两个方法中使用：</p>

<ul>

<li><p><a href="#approach3">方法 3: 在局部类中指定搜索条件代码</a> 中的 <code>public static void printPersons(List&lt;Person&gt; roster, CheckPerson tester)</code></p></li>

<li><p><a href="#approach6">方法 6: 在 Lambda 表达式中使用标准的函数式接口</a> 中的 <code>public void printPersonsWithPredicate(List&lt;Person&gt; roster, Predicate&lt;Person&gt; tester)</code></p></li>

</ul>

<p>当 Java 运行时调用 <code>printPersons</code> 方法时，它期望的事 <code>CheckPerson</code> 数据类型，所以 lambda 表达式就是这种类型。
    然而，当 Java 运行时调用 <code>printPersonsWithPredicate</code> 方法时，它期望的是 <code>Predicate&lt;Person&gt;</code> 数据类型，所以
    lambda 表达式就是这种类型。这些方法期望的数据类型叫做 <em>目标类型</em>。为确定 lambda 表达式的类型，Java 编译器使用 lambda 表达式所在上下文或情境中的目标类型。
    您只能在 Java 编译器可以确定目标类型的情景中使用 lambda 表达式：</p>

<ul>
  <li><p>变量声明</p></li>
  <li><p>赋值</p></li>
  <li><p>返回语句</p></li>
  <li><p>数组初始化</p></li>
  <li><p>方法或构造器参数</p></li>
  <li><p>lambda 表达式体</p></li>
  <li><p>条件表达式 <code>?:</code></p></li>
  <li><p>类型转换表达式</p></li>
</ul>

<h3><a name="target-types-and-method-arguments">目标类型和方法参数</a></h3>

<p>对于方法参数，Java 编译器使用两个其它语言特性决定目标类型：重载解析和类型参数推断。</p>

<p>考虑下面两个函数式接口 (<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html"><code>java.lang.Runnable</code></a> 和
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Callable.html"><code>java.util.concurrent.Callable&lt;V&gt;</code></a>)：</p>

<pre class="codeblock">public interface Runnable {
    void run();
}

public interface Callable&lt;V&gt; {
    V call();
}</pre>

<p><code>Runnable.run</code> 方法没有返回值，而 <code>Callable&lt;V&gt;.call</code> 有。</p>

<p>假设您重载了 <code>invoke</code> 方法 (查看 <a class="TutorialLink" target="_top" href="methods.html">定义方法</a> 获取关于方法重载的信息)：</p>

<pre class="codeblock">void invoke(Runnable r) {
    r.run();
}

&lt;T&gt; T invoke(Callable&lt;T&gt; c) {
    return c.call();
}</pre>

<p>下面的语句将调用哪个方法呢？</p>

<pre class="codeblock">String s = invoke(() -&gt; "done");</pre>

<p><code>invoke(Callable&lt;T&gt;)</code> 方法将被调用，因为这个方法返回一个值，而 <code>invoke(Runnable)</code> 没有。
    这个例子中，lambda 表达式 <code>() -&gt; "done"</code> 的类型是 <code>Callable&lt;T&gt;</code>。</p>

<h2><a name="serialization">序列化</a></h2>

<p>如果目标类型和捕获到的参数是可序列化的，那就可以 <a class="TutorialLink" target="_top" href="../../jndi/objects/serial.html">序列化</a> lambda
    表达式。然而，就像 <a class="TutorialLink" target="_top" href="nested.html#serialization">内部类</a>，对 lambda 表达式序列化也是强烈不推荐的。</p>

        </div>
        <div class="NavBit">
            <a target="_top" href="anonymousclasses.html">上一页</a>
            &bull;
            <a target="_top" href="../TOC.html">目录</a>
            &bull;
            <a target="_top" href="methodreferences.html">下一页</a>
        </div>
    </div>
    
<hr class="clearfloat"/>

<div id="Footer">

<p class="footertext">
<a href="https://www.oracle.com/corporate/">About Oracle</a> | 
<a href="https://www.oracle.com/corporate/contact/">Contact Us</a> |
<a href="https://www.oracle.com/legal/">Legal Notices</a> | 
<a href="https://www.oracle.com/legal/terms.html">Terms of Use</a> |
<a href="https://www.oracle.com/legal/privacy/">Your Privacy Rights</a></p>

<p class="footertext"><a href="http://www.oracle.com/pls/topic/lookup?ctx=cpyr&id=en-US">
Copyright &copy; 1995, 2022 Oracle and/or its affiliates. All rights reserved.</a></p>
       
</div>    
    <div class="PrintHeaders">
        <b>上一页：</b> 匿名类
        <br /><b>下一页：</b> 方法引用
    </div>
</body>
</html> 
